using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using PhotoApp.Data;
using PhotoApp.Models;
using QRCoder;

namespace PhotoApp.Controllers;
[Authorize]
public class HomeController : Controller
{
    private readonly AppDbContext _context;
    private readonly IWebHostEnvironment _env;
    private readonly ILogger<HomeController> _logger;

    public HomeController(AppDbContext context, IWebHostEnvironment env, ILogger<HomeController> logger)
    {
        _context = context;
        _env = env;
        _logger = logger;
    }

    // GET: /
    public async Task<IActionResult> Index()
    {
        var photos = await _context.Photos.OrderByDescending(p => p.CreatedAt).ToListAsync();
        return View(photos);
    }

    // GET: /Home/Create
    public IActionResult Create() => View();

    // POST: /Home/Create
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Create(PhotoRecord record, IFormFile? imageFile)
    {
        if (!ModelState.IsValid)
            return View(record);

        if (imageFile != null && imageFile.Length > 0)
        {
            var permitted = new[] { "image/jpeg", "image/png", "image/gif", "image/webp" };
            if (!permitted.Contains(imageFile.ContentType))
            {
                ModelState.AddModelError("imageFile", "Nepodporovaný formát obrázku.");
                return View(record);
            }

            var uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads))
                Directory.CreateDirectory(uploads);

            var fileName = Path.GetFileNameWithoutExtension(imageFile.FileName)
                           + "_" + Guid.NewGuid().ToString("N")
                           + Path.GetExtension(imageFile.FileName);
            var path = Path.Combine(uploads, fileName);

            using (var stream = new FileStream(path, FileMode.Create))
            {
                await imageFile.CopyToAsync(stream);
            }

            record.PhotoPath = "/uploads/" + fileName;
        }

        record.CreatedAt = DateTime.UtcNow;
        record.UpdatedAt = DateTime.UtcNow;

        _context.Add(record);
        await _context.SaveChangesAsync();

        return RedirectToAction(nameof(Index));
    }
    // Replace the existing ClearPhotos method with this implementation
    // POST: /Home/ClearPhotos
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> ClearPhotos()
    {
        try
        {
            // 1) Smažeme všechny záznamy v DB (tabulka Photos)
            var allPhotos = await _context.Photos.ToListAsync();
            if (allPhotos.Any())
            {
                _context.Photos.RemoveRange(allPhotos);
                await _context.SaveChangesAsync();
            }

            // 2) Smažeme všechny soubory a podsložky v wwwroot/uploads
            var uploadsDir = Path.Combine(_env.WebRootPath ?? Path.Combine(AppContext.BaseDirectory, "wwwroot"), "uploads");
            try
            {
                if (Directory.Exists(uploadsDir))
                {
                    // smažeme celou složku uploads a znovu ji vytvoøíme èistou
                    Directory.Delete(uploadsDir, recursive: true);
                }
                // vždy vytvoøíme prázdnou složku uploads (aplikace oèekává její existenci)
                Directory.CreateDirectory(uploadsDir);
            }
            catch (Exception ex)
            {
                // logovat pokud máš _logger, jinak uložíme do TempData
                try { _logger?.LogWarning(ex, "Failed to clear/create uploads directory"); } catch { }
                TempData["Error"] = "Složku uploads se nepodaøilo plnì vyèistit: " + ex.Message;
                return RedirectToAction("Index", "Photos");
            }

            // 3) Natvrdo smazat SQLite soubor databáze (a -wal, -shm)
            var dbPath = Path.Combine(AppContext.BaseDirectory, "photoapp.db");
            var walPath = dbPath + "-wal";
            var shmPath = dbPath + "-shm";

            // Pokusíme se zavøít pøipojení DbContextu, aby nebyl soubor zablokovaný
            try
            {
                await _context.Database.CloseConnectionAsync();
            }
            catch
            {
                // ignorujeme chybu pøi zavírání, pokusíme se smazat pøes retry
            }

            bool dbDeleted = false;
            if (System.IO.File.Exists(dbPath))
            {
                const int maxAttempts = 8;
                for (int attempt = 1; attempt <= maxAttempts; attempt++)
                {
                    try
                    {
                        // uvolnìní pøípadných nedokonèených streamù
                        GC.Collect();
                        GC.WaitForPendingFinalizers();

                        System.IO.File.Delete(dbPath);
                        dbDeleted = true;
                        break;
                    }
                    catch (IOException ioEx)
                    {
                        try { _logger?.LogWarning(ioEx, "Attempt {Attempt} to delete DB file failed (in use).", attempt); } catch { }
                        // èekáme a zkusíme znovu
                        await Task.Delay(300 * attempt);
                    }
                    catch (UnauthorizedAccessException uaEx)
                    {
                        try { _logger?.LogWarning(uaEx, "Attempt {Attempt} to delete DB file failed (access).", attempt); } catch { }
                        await Task.Delay(300 * attempt);
                    }
                    catch (Exception ex)
                    {
                        try { _logger?.LogError(ex, "Unexpected error when deleting DB file"); } catch { }
                        break;
                    }
                }
            }
            else
            {
                // pokud soubor neexistuje, považujeme to za úspìch (už je smazaný)
                dbDeleted = true;
            }

            // Pokusíme se smazat -wal a -shm soubory (ignorujeme chyby)
            try { if (System.IO.File.Exists(walPath)) System.IO.File.Delete(walPath); } catch (Exception ex) { _logger?.LogWarning(ex, "Failed to delete wal file"); }
            try { if (System.IO.File.Exists(shmPath)) System.IO.File.Delete(shmPath); } catch (Exception ex) { _logger?.LogWarning(ex, "Failed to delete shm file"); }

            if (!dbDeleted)
            {
                TempData["Error"] = "Databázový soubor se nepodaøilo smazat (pravdìpodobnì je zamèen). Zastav aplikaci a zkuste to znovu.";
                return RedirectToAction("Index", "Photos");
            }

            TempData["Message"] = "Všechny záznamy v tabulce Photos byly odstranìny, uploads byla vyprázdnìna a databázový soubor byl smazán.";
        }
        catch (Exception ex)
        {
            // obecné zachycení chyb
            try { _logger?.LogError(ex, "Error in ClearPhotos"); } catch { }
            TempData["Error"] = "Chyba pøi mazání: " + ex.Message;
        }

        return RedirectToAction("Index", "Photos");
    }


    // GET: /Home/Details/{id}  (pøihlášený uživatel, zobrazí QR kód odkazující na veøejný detail)
    public async Task<IActionResult> Details(int id)
    {
        var photo = await _context.Photos.FindAsync(id);
        if (photo == null)
            return NotFound();

        // bezpeènì sestavíme publicUrl; použijeme Context (dostupné v Razor view i tady)
        var scheme = Request?.Scheme ?? "https";
        var publicUrl = Url.Action("DetailsAnonymous", "Photos", new { id = photo.Id }, scheme);
        ViewBag.PublicUrl = publicUrl;

        // pokud publicUrl je platný string, zkusíme vygenerovat SVG; jinak ponecháme null a použijeme fallback
        if (!string.IsNullOrWhiteSpace(publicUrl))
        {
            try
            {
                ViewBag.PublicQrSvg = GenerateQrSvg(publicUrl);
                ViewBag.PublicQrError = null;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Generování QR SVG selhalo pro url {Url}", publicUrl);
                ViewBag.PublicQrSvg = null;
                ViewBag.PublicQrError = ex.Message;
            }
        }
        else
        {
            ViewBag.PublicQrSvg = null;
            ViewBag.PublicQrError = "Public URL je prázdné.";
        }

        return View(photo);
    }

    // GET: /Home/DetailsAnonymous/{id}
    [AllowAnonymous]
    public async Task<IActionResult> DetailsAnonymous(int id)
    {
        var photo = await _context.Photos.FindAsync(id);
        if (photo == null)
            return NotFound();

        // pùvodnì
        // return View("DetailsAnonymous", photo);

        // nahraïte tímto:
        return View("~/Views/Photos/DetailsAnonymous.cshtml", photo);
    }

    // Pomocná metoda: vytvoøí SVG string QR kódu (SvgQRCode) - cross-platform
    private string GenerateQrSvg(string payload)
    {
        if (string.IsNullOrWhiteSpace(payload))
            throw new ArgumentNullException(nameof(payload));

        using var qrGen = new QRCodeGenerator();
        using var qrData = qrGen.CreateQrCode(payload, QRCodeGenerator.ECCLevel.Q);
        var svgQr = new SvgQRCode(qrData);
        return svgQr.GetGraphic(4); // vrací SVG string
    }
}